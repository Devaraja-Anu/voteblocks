// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: votes.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countVotesByOption = `-- name: CountVotesByOption :many
SELECT option, COUNT(*) as vote_count
FROM votes
WHERE poll_id = $1
GROUP BY option
ORDER BY vote_count DESC
`

type CountVotesByOptionRow struct {
	Option    string `json:"option"`
	VoteCount int64  `json:"vote_count"`
}

func (q *Queries) CountVotesByOption(ctx context.Context, pollID int32) ([]CountVotesByOptionRow, error) {
	rows, err := q.db.Query(ctx, countVotesByOption, pollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountVotesByOptionRow{}
	for rows.Next() {
		var i CountVotesByOptionRow
		if err := rows.Scan(&i.Option, &i.VoteCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createVote = `-- name: CreateVote :one
INSERT INTO votes (user_id, poll_id, option)
VALUES ($1, $2, $3)
RETURNING id, poll_id, user_id, option, created_at
`

type CreateVoteParams struct {
	UserID pgtype.UUID `json:"user_id"`
	PollID int32       `json:"poll_id"`
	Option string      `json:"option"`
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) (Vote, error) {
	row := q.db.QueryRow(ctx, createVote, arg.UserID, arg.PollID, arg.Option)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.PollID,
		&i.UserID,
		&i.Option,
		&i.CreatedAt,
	)
	return i, err
}

const getVoteByUserAndPoll = `-- name: GetVoteByUserAndPoll :one
SELECT id, poll_id, user_id, option, created_at FROM votes WHERE user_id = $1 AND poll_id = $2
`

type GetVoteByUserAndPollParams struct {
	UserID pgtype.UUID `json:"user_id"`
	PollID int32       `json:"poll_id"`
}

func (q *Queries) GetVoteByUserAndPoll(ctx context.Context, arg GetVoteByUserAndPollParams) (Vote, error) {
	row := q.db.QueryRow(ctx, getVoteByUserAndPoll, arg.UserID, arg.PollID)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.PollID,
		&i.UserID,
		&i.Option,
		&i.CreatedAt,
	)
	return i, err
}

const getVotesByPoll = `-- name: GetVotesByPoll :many
SELECT id, poll_id, user_id, option, created_at FROM votes WHERE poll_id = $1
`

func (q *Queries) GetVotesByPoll(ctx context.Context, pollID int32) ([]Vote, error) {
	rows, err := q.db.Query(ctx, getVotesByPoll, pollID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Vote{}
	for rows.Next() {
		var i Vote
		if err := rows.Scan(
			&i.ID,
			&i.PollID,
			&i.UserID,
			&i.Option,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
