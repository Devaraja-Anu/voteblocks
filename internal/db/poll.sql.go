// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: poll.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPoll = `-- name: CreatePoll :one
INSERT INTO polls (title, description, options, created_by,expires_at)
VALUES ($1, $2, $3, $4,$5)
RETURNING id, title, description, options, created_by, created_at, expires_at, active
`

type CreatePollParams struct {
	Title       string           `json:"title"`
	Description *string          `json:"description"`
	Options     []string         `json:"options"`
	CreatedBy   pgtype.UUID      `json:"created_by"`
	ExpiresAt   pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreatePoll(ctx context.Context, arg CreatePollParams) (Poll, error) {
	row := q.db.QueryRow(ctx, createPoll,
		arg.Title,
		arg.Description,
		arg.Options,
		arg.CreatedBy,
		arg.ExpiresAt,
	)
	var i Poll
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Options,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Active,
	)
	return i, err
}

const getPoll = `-- name: GetPoll :one
SELECT id, title, description, options, created_by, created_at, expires_at, active FROM polls WHERE id = $1
`

func (q *Queries) GetPoll(ctx context.Context, id int32) (Poll, error) {
	row := q.db.QueryRow(ctx, getPoll, id)
	var i Poll
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Options,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Active,
	)
	return i, err
}

const getPollsByUser = `-- name: GetPollsByUser :many
SELECT id, title, description, options, created_by, created_at, expires_at, active FROM polls
WHERE created_by = $1 
AND (to_tsvector('simple', title) @@ plainto_tsquery('simple', $1) OR $1 = '') ORDER BY created_at DESC
`

func (q *Queries) GetPollsByUser(ctx context.Context, createdBy pgtype.UUID) ([]Poll, error) {
	rows, err := q.db.Query(ctx, getPollsByUser, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Poll{}
	for rows.Next() {
		var i Poll
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Options,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPolls = `-- name: ListPolls :many
SELECT id, title, description, options, created_by, created_at, expires_at, active FROM polls
WHERE active = true AND (expires_at IS NULL OR expires_at > now())
ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListPollsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPolls(ctx context.Context, arg ListPollsParams) ([]Poll, error) {
	rows, err := q.db.Query(ctx, listPolls, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Poll{}
	for rows.Next() {
		var i Poll
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Options,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.Active,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
